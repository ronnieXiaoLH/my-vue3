# Vue3.0核心源码解析

## Vue3.0的优化

- 源码优化：
  1. 更好的代码管理方式：monorepo
  2. 使用 TypeScript

- 性能优化：
  1. 源码体积的优化
    - 移除冷门的 feature (filter、inline-template...)
    - tree-shaking (未使用 transition、keep-alive等组件不会被打包进去)
  2. 数据劫持的优化
    - Vue 2.x 通过 Object.defineProperty() 无法知道对象的新增、删除，对象层级较深需要递归劫持
    - Vue 3.x 通过 Proxy 直接劫持整个对象，对于子对象的劫持在 getter 中实现，只有子对象被访问到才会被劫持，避免了无脑劫持
  3. 编译的优化
    - 编译阶段优化编译结果，来实现运行时 patch 过程的优化
    - Vue 2.x 数据更新并触发重新渲染的粒度是组件级的
    - Vue 3.x 通过对编译阶段对静态模板的分析，生成 Block tree，vnode 更新性能由与模版整体大小相关提升为与动态内容的数量相关
    - 重复的静态节点提取
  4. diff 算法的优化

- 语法 API 的优化：
  1. 优化组织逻辑
    - Vue 2.x Options API 通过 data、props、methods 的方式，当组件有多个逻辑关注点时，修改某个逻辑关注点需要在文件不断的上下切换和查找
    - Vue 3.x Composition API 可以将每个逻辑关注点的代码放在一起
  2. 优化逻辑复用
    - Vue 2.x mixins 可能引起命名冲突，且数据来源不清晰
    - Vue 3.x 通过自定义 Hook 的方式，有更好的类型支持，也利于 tree-shaking
  
- 引入 RFC (Request For Comments)
  每一条重大的改动都有 RFC ，通过阅读 RFC 你可以了解每一个 feature 采用或被废弃掉的前因后果




## Reactive 原理解析

1. 如果是基础数据类型会直接返回，不能代理
2. 如果已经被 readonly 代理的对象，不能再次代理，直接返回
3. 如果对象有 `__v_skip` 属性(markRow()会给对象新增该属性)或者不能扩展，即不能被代理，直接返回
4. 对于引用数据类型，会分为两类，(Array / Object) 和 (Map / Set / WeakMap / WeakSet)，第一类的处理是 baseHandlers，第二类是 collectionHandlers
5. 对于数组的 `'includes', 'indexOf', 'lastIndexOf'` 方法重新改写了，对数组的每一项进行代理，对于数组的 `'push', 'pop', 'shift', 'unshift', 'splice'` 方法做了暂停依赖收集，因为访问这些方法修改了数组的长度，会默认访问数组的 `length` 属性
6. 在 Proxy 的 get 方法里，判断了是内置的 symbol 属性，或者原型链的属性，或者是 vue 内部的属性，不收集依赖
7. 如果不是 readonly 则收集依赖
8. 如果是 shallow 返回值
9. 如果不是 shallow ，看返回值的类型是不是对象，如果是对象，递归处理，是 readonly，用 readonly 处理，不是用 reactive 处理
10. baseHandlers get 对 ref 特殊处理了
11. 首先判断是新增属性还是修改属性的值，如果是数组，判断属性是不是索引，如果是，看是不是小于数组的长度，如果是表示是修改属性的值，如果是对象，判断属性是不是对象原有的属性，如果是表示是修改属性的值

依赖收集：将 activeEffect 与 target[key] 关联起来，activeEffect 里面包含更新要执行的方法，类似于 Vue2 的 render watcher 里保存了重新更新渲染的方法
触发更新：根据已经关联的 activeEffect 与 target[key]，执行对应的 activeEffect 来更新视图

## ref 原理解析

如果是基础类型的数据，数据是通过类的 get value 和 set value 对数据进行依赖收集和派发更新的，本质是 Object.defineProperty，如果是对象，其实还是用的 reactive

Vue3 和 Vue2 不同的是，Vue2 是在数据初始化的时候就递归做响应式处理，Vue3 是懒处理，在取值的时候才递归处理

## computed 原理解析

computed 其实也是 effect，会将用户传进来的函数或者对象构造出 getter 和 setter，会将 getter 作为参数创建出 effect，同时会标识 lazy 和 scheduler，lazy 的作用是标识 effect 不执行，因为创建出的 effect 默认会执行一次，scheduler 是一个函数，主要作用就是将 computed 的 _dirty 属性的值改为 true，因为当 computed 里面依赖的状态的值变化后，再获取 computed 的值是要重新计算的。

computed 也是要进行依赖收集的，在获取值的时候进行依赖收集，在 scheduler 执行的时候派发更新

## Vue3 的渲染流程

1. runtime-core 导出核心的 createRenderer 和 h 方法
2. createRenderer 函数返回 createApp 函数
3. createApp 函数接收一个根组件和props，返回 app 实例，app 实例有一个 mount 方法，mount 方法首先根据 根组件和props 创建出 VNode，然后调用 render 方法渲染
4. render 方法的核心就是 patch
5. patch 的如果是组件，`1`首先会创建组件的实例，`2`然后在实例上挂载需要的数据，我们调用 setup 方法的参数里的数据就是来源于创建的组件的实例。
6. 判断 setup 方法的返回值类型，如果返回的是对象，就是返回的是数据，这些数据都会被代理到 proxy 上，因为组件配置的 render 的第一个参数就是 proxy，可以通过 proxy 直接访问 setup 返回的数据，props 接收的数据，或者 vue2 写法 data 中的数据。如果返回的是一个函数，那么就当做是 render 函数，它的优先级高于组件配置的 render
7. `3` 创建一个 effect 让 render 函数执行，effect 的第一个参数就是执行渲染的方法，当执行渲染方法的时候，如果有获取数据，那么这个 effect 就是被数据收集起来，所以当数据更新的时候会更新渲染，同时也说明是组件级的更新。同时对于多次修改状态的值，effect 定义了一个 scheduler，多次修改的 effect 会被收集到队列中，且去重，最后根据 effect 的 id 从小到大排序，因为父组件先创建，更新时也要保证顺序。

## Vue3 的跨平台和扩展平台

Vue3 有一个核心包 runtime-core ，执行 createApp 方法返回的是一个 app 实例，实例里有 mount 方法，它负责生成 Vnode，并调用 render 函数进行渲染，但是渲染需要进行的所有相关的操作，都是传进来的。
比如在浏览器环境，runtime-dom 包将渲染所需要的 DOM 的操作都传给了 runtime-core，同时 runtime-dom 可以改写 runtime-core 返回的 mount 方法，比如在挂载元素之前，先清空被挂载元素的内容，runtime-core 都是一些很纯粹的工作，和平台无关。

## Vue3 diff

1. 判断是否是相同节点，如果不是则删除旧节点，插入新节点
2. 如果是相同的节点，更新 props
3. 比对子节点

### diff 算法的核心 - 子节点比对

1. 如果新的节点不是数组，旧的节点是数组，删除旧的儿子，设置新的文本；如果新的节点是数组，旧的节点不是数组，新增子节点；如果新旧节点都是文本，文本内容不同就更新文本
2. 首先是从新旧子节点的头部开始比对，遇到不是相同节点就停止
3. 从新旧子节点的尾部开始比对，遇到不是相同的节点就停止
4. 如果是新的子节点多(满足一定的判断条件)，新增新的子节点(新增时需要保证插入的顺序)
5. 如果是旧的子节点多(满足一定的判断条件)，删除旧的多的子节点
6. 乱序比对，以新的子节点做映射表(Vue2是以旧的子节点做映射表)，遍历旧的子节点，如果在映射表中找到了，复用该旧的子节点，反之，删除旧的子节点

--------------------------------------------------------------------

经过上面 5 个步骤后，还有两个问题待解决：
1. 乱序比对，复用的旧的子节点的位置还是旧的位置，即位置待更新
2. 乱序比对中，未被复用的子节点还需新增

-------------------------------------------------------------------------

解决问题：
1. 在乱序比对的时候，用一个数组用来标记新节点哪些被复用了，没有被复用的节点，数组该索引位的值为 0，被复用的数组该索引位的值为 旧节点的索引 + 1，这里 + 1 是避免值为 0
2. 遍历数组，判断数组的值是否为 0，为 0 表示没有被复用的节点，直接插入即可，被复用的节点虽然它的 el 是直接复用 旧节点的 el，但是如果直接插入，相当于乱序比对的每个节点都移动了一次，这里还有优化的空间。
3. 最长递增子序列

## 组件更新

组件哪些情况会更新？

1. 自身的数据更新了
2. 外界属性变化了(可以属性，插槽等)

如果父组件传给子组件的属性更新了，子组件该如何更新呢？

  - 子组件要更新，不管子组件是否使用了该属性，子组件都应该更新
  - 子组件使用了该属性，子组件要更新视图
  
  但是如果这样，子组件就更新了两次？？？

  Vue3 内部做了处理，会把组件自身的更新任务从队列中删除

## 编译过程

- 先对模板进行分析，生成 ast 树
- transform -> 做转换过程，对动态节点进行标记 (指令，插槽，事件，属性)
- codegen -> 代码生成

## Block 的概念

收集动态节点，在 createVnode 的时候，会判断这个节点是不是动态的，是就让外层的 block 收集起来(只要会影响结构的，都会被标记成 block 节点)

作用：将树的递归拍平成了一个数组

目的：diff 的时候，只比对动态的节点

## 生命周期

Vue3 生命周期实现思路就是在组件的实例上挂载对应的生命周期的回调函数，然后在渲染的合适的时机依次执行这些回调函数(比如组件初次渲染时，在渲染之前执行 beforeMount 的回调，在渲染完成后执行 mounted 的回调)

在 setup 执行之前，将 currentInstance 指向组件的 instance，在 setup 执行完成之后，再将 currentInstance 置为 null

这里有一个问题需要注意，就是子组件先 mounted，然后父组件 mounted，但是在执行父组件 mounted 的时候，currentInstance 已经指向 子组件的 instance 了，如何解决这一问题呢？

hooks 数组里保存的生命周期的回调是经过函数包装过的，保存的是包装过的函数，包装的函数主要做三件事，一是将 currentInstance 指向当前的实例，执行生命周期的回调函数并将this指向当前实例，然后将 currentInstance 置为 null

如何改变 currentInstance 的指向，component.ts 导出了 setCurrentInstance 方法，而且 导出了 getCurrentInstance 函数，这样在声明周期的回调里也可以通过该函数获取组件的实例

## 模板编译

- 先解析模板生成 ast
- transform
- 代码生成

只有经过模板编译才能做优化，标记动态节点，生成 Block Tree，直接写 render 函数或者 JSX 是无法做编译优化的

1. 生成AST

主要思想就是依次解析模板字符串，解析的内容大致分为几类，标签，文本，插值表达式，属性等，不论是解析到上那种类型，都是子节点，然后截取对应的字符串，解析模板后面的字符串。节点主要记录类型、位置信息(行、列、偏移量)、内容等。

